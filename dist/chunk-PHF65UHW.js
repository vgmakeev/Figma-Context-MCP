import{b as C,g as M,l as _}from"./chunk-GBF3ZY7S.js";import{a,b as R}from"./chunk-Q77VG2BX.js";import{McpServer as ae}from"@modelcontextprotocol/sdk/server/mcp.js";import N from"path";import B from"fs";import j from"sharp";async function X(r,t){let{Logger:e}=await import("./logger-RNG6OBLU.js");try{let i=t[0]?.[0]??1,s=t[0]?.[1]??0,o=t[0]?.[2]??0,n=t[1]?.[0]??0,l=t[1]?.[1]??1,w=t[1]?.[2]??0,u=j(r),c=await u.metadata();if(!c.width||!c.height)throw new Error(`Could not get image dimensions for ${r}`);let{width:y,height:h}=c,f=Math.max(0,Math.round(o*y)),g=Math.max(0,Math.round(w*h)),p=Math.min(y-f,Math.round(i*y)),m=Math.min(h-g,Math.round(l*h));if(p<=0||m<=0)return e.log(`Invalid crop dimensions for ${r}, using original image`),r;let d=r+".tmp";return await u.extract({left:f,top:g,width:p,height:m}).toFile(d),B.renameSync(d,r),e.log(`Cropped image saved (overwritten): ${r}`),e.log(`Crop region: ${f}, ${g}, ${p}x${m} from ${y}x${h}`),r}catch(i){return e.error(`Error cropping image ${r}:`,i),r}}async function G(r){let{Logger:t}=await import("./logger-RNG6OBLU.js");try{let e=await j(r).metadata();if(!e.width||!e.height)throw new Error(`Could not get image dimensions for ${r}`);return{width:e.width,height:e.height}}catch(e){return t.error(`Error getting image dimensions for ${r}:`,e),{width:1e3,height:1e3}}}async function x(r,t,e,i=!1,s,o=!1){let{Logger:n}=await import("./logger-RNG6OBLU.js"),l=[],{downloadFigmaImage:w}=await import("./common-D7KV4EZS.js"),u=await w(r,t,e);n.log(`Downloaded original image: ${u}`);let c=await G(u);n.log(`Original dimensions: ${c.width}x${c.height}`);let y=u,h=!1,f;if(i&&s){n.log("Applying crop transform...");let m=s[0]?.[0]??1,d=s[1]?.[1]??1,v=s[0]?.[2]??0,I=s[1]?.[2]??0,S=Math.max(0,Math.round(v*c.width)),F=Math.max(0,Math.round(I*c.height)),T=Math.min(c.width-S,Math.round(m*c.width)),E=Math.min(c.height-F,Math.round(d*c.height));T>0&&E>0?(f={left:S,top:F,width:T,height:E},y=await X(u,s),h=!0,n.log(`Cropped to region: ${S}, ${F}, ${T}x${E}`)):n.log("Invalid crop dimensions, keeping original image")}let g=await G(y);n.log(`Final dimensions: ${g.width}x${g.height}`);let p;return o&&(p=J(g)),{filePath:y,originalDimensions:c,finalDimensions:g,wasCropped:h,cropRegion:f,cssVariables:p,processingLog:l}}function J({width:r,height:t}){return`--original-width: ${r}px; --original-height: ${t}px;`}import{execFile as Z}from"child_process";import{promisify as Q}from"util";var ee=Q(Z);async function q(r,t={}){try{let e=await fetch(r,t);if(!e.ok)throw new Error(`Fetch failed with status ${e.status}: ${e.statusText}`);return await e.json()}catch(e){a.log(`[fetchWithRetry] Initial fetch failed for ${r}: ${e.message}. Likely a corporate proxy or SSL issue. Attempting curl fallback.`);let s=["-s","-S","--fail-with-body","-L",...te(t.headers),r];try{a.log(`[fetchWithRetry] Executing curl with args: ${JSON.stringify(s)}`);let{stdout:o,stderr:n}=await ee("curl",s);if(n){if(!o||n.toLowerCase().includes("error")||n.toLowerCase().includes("fail"))throw new Error(`Curl command failed with stderr: ${n}`);a.log(`[fetchWithRetry] Curl command for ${r} produced stderr (but might be informational): ${n}`)}if(!o)throw new Error("Curl command returned empty stdout.");let l=JSON.parse(o);if(l.status&&l.status!==200)throw new Error(`Curl command failed: ${l}`);return l}catch(o){throw a.error(`[fetchWithRetry] Curl fallback also failed for ${r}: ${o.message}`),e}}}function te(r){if(!r)return[];let t=[];for(let[e,i]of Object.entries(r))t.push("-H",`${e}: ${i}`);return t}var O=class{apiKey;oauthToken;useOAuth;baseUrl="https://api.figma.com/v1";constructor({figmaApiKey:t,figmaOAuthToken:e,useOAuth:i}){this.apiKey=t||"",this.oauthToken=e||"",this.useOAuth=!!i&&!!this.oauthToken}getAuthHeaders(){return this.useOAuth?(a.log("Using OAuth Bearer token for authentication"),{Authorization:`Bearer ${this.oauthToken}`}):(a.log("Using Personal Access Token for authentication"),{"X-Figma-Token":this.apiKey})}filterValidImages(t){return t?Object.fromEntries(Object.entries(t).filter(([,e])=>!!e)):{}}async request(t){try{a.log(`Calling ${this.baseUrl}${t}`);let e=this.getAuthHeaders();return await q(`${this.baseUrl}${t}`,{headers:e})}catch(e){let i=e instanceof Error?e.message:String(e);throw new Error(`Failed to make request to Figma API endpoint '${t}': ${i}`)}}buildSvgQueryParams(t,e){return new URLSearchParams({ids:t.join(","),format:"svg",svg_outline_text:String(e.outlineText),svg_include_id:String(e.includeId),svg_simplify_stroke:String(e.simplifyStroke)}).toString()}async getImageFillUrls(t){let e=`/files/${t}/images`;return(await this.request(e)).meta.images||{}}async getNodeRenderUrls(t,e,i,s={}){if(e.length===0)return{};if(i==="png"){let o=s.pngScale||2,n=`/images/${t}?ids=${e.join(",")}&format=png&scale=${o}`,l=await this.request(n);return this.filterValidImages(l.images)}else{let o=s.svgOptions||{outlineText:!0,includeId:!1,simplifyStroke:!0},n=this.buildSvgQueryParams(e,o),l=`/images/${t}?${n}`,w=await this.request(l);return this.filterValidImages(w.images)}}async downloadImages(t,e,i,s={}){if(i.length===0)return[];let o=N.normalize(e).replace(/^(\.\.(\/|\\|$))+/,""),n=N.resolve(o);if(!n.startsWith(N.resolve(process.cwd())))throw new Error("Invalid path specified. Directory traversal is not allowed.");let{pngScale:l=2,svgOptions:w}=s,u=[],c=i.filter(f=>!!f.imageRef),y=i.filter(f=>!!f.nodeId);if(c.length>0){let f=await this.getImageFillUrls(t),g=c.map(({imageRef:p,fileName:m,needsCropping:d,cropTransform:v,requiresImageDimensions:I})=>{let S=f[p];return S?x(m,n,S,d,v,I):null}).filter(p=>p!==null);g.length>0&&u.push(Promise.all(g))}if(y.length>0){let f=y.filter(p=>!p.fileName.toLowerCase().endsWith(".svg")),g=y.filter(p=>p.fileName.toLowerCase().endsWith(".svg"));if(f.length>0){let p=await this.getNodeRenderUrls(t,f.map(d=>d.nodeId),"png",{pngScale:l}),m=f.map(({nodeId:d,fileName:v,needsCropping:I,cropTransform:S,requiresImageDimensions:F})=>{let T=p[d];return T?x(v,n,T,I,S,F):null}).filter(d=>d!==null);m.length>0&&u.push(Promise.all(m))}if(g.length>0){let p=await this.getNodeRenderUrls(t,g.map(d=>d.nodeId),"svg",{svgOptions:w}),m=g.map(({nodeId:d,fileName:v,needsCropping:I,cropTransform:S,requiresImageDimensions:F})=>{let T=p[d];return T?x(v,n,T,I,S,F):null}).filter(d=>d!==null);m.length>0&&u.push(Promise.all(m))}}return(await Promise.all(u)).flat()}async getRawFile(t,e){let i=`/files/${t}${e?`?depth=${e}`:""}`;a.log(`Retrieving raw Figma file: ${t} (depth: ${e??"default"})`);let s=await this.request(i);return R("figma-raw.json",s),s}async getRawNode(t,e,i){let s=`/files/${t}/nodes?ids=${e}${i?`&depth=${i}`:""}`;a.log(`Retrieving raw Figma node: ${e} from ${t} (depth: ${i??"default"})`);let o=await this.request(s);return R("figma-raw.json",o),o}};import{z as k}from"zod";import oe from"js-yaml";var L={fileKey:k.string().regex(/^[a-zA-Z0-9]+$/,"File key must be alphanumeric").describe("The key of the Figma file to fetch, often found in a provided URL like figma.com/(file|design)/<fileKey>/..."),nodeId:k.string().regex(/^I?\d+[:|-]\d+(?:;\d+[:|-]\d+)*$/,"Node ID must be like '1234:5678' or 'I5666:180910;1:10515;1:10336'").optional().describe("The ID of the node to fetch, often found as URL parameter node-id=<nodeId>, always use if provided. Use format '1234:5678' or 'I5666:180910;1:10515;1:10336' for multiple nodes."),depth:k.number().optional().describe("OPTIONAL. Do NOT use unless explicitly requested by the user. Controls how many levels deep to traverse the node tree.")},se=k.object(L);async function re(r,t,e){try{let{fileKey:i,nodeId:s,depth:o}=se.parse(r),n=s?.replace(/-/g,":");a.log(`Fetching ${o?`${o} layers deep`:"all layers"} of ${n?`node ${n} from file`:"full file"} ${i}`);let l;n?l=await t.getRawNode(i,n,o):l=await t.getRawFile(i,o);let w=C(l,M,{maxDepth:o,afterChildren:_});R("figma-simplified.json",w),a.log(`Successfully extracted data: ${w.nodes.length} nodes, ${Object.keys(w.globalVars.styles).length} styles`);let{nodes:u,globalVars:c,...y}=w,h={metadata:y,nodes:u,globalVars:c};a.log(`Generating ${e.toUpperCase()} result from extracted data`);let f=e==="json"?JSON.stringify(h,null,2):oe.dump(h);return a.log("Sending result to client"),{content:[{type:"text",text:f}]}}catch(i){let s=i instanceof Error?i.message:JSON.stringify(i);return a.error(`Error fetching file ${r.fileKey}:`,s),{isError:!0,content:[{type:"text",text:`Error fetching file: ${s}`}]}}}var A={name:"get_figma_data",description:"Get comprehensive Figma file data including layout, content, visuals, and component information",parameters:L,handler:re};import{z as b}from"zod";var U={fileKey:b.string().regex(/^[a-zA-Z0-9]+$/,"File key must be alphanumeric").describe("The key of the Figma file containing the images"),nodes:b.object({nodeId:b.string().regex(/^I?\d+[:|-]\d+(?:;\d+[:|-]\d+)*$/,"Node ID must be like '1234:5678' or 'I5666:180910;1:10515;1:10336'").describe("The ID of the Figma image node to fetch, formatted as 1234:5678"),imageRef:b.string().optional().describe("If a node has an imageRef fill, you must include this variable. Leave blank when downloading Vector SVG images."),fileName:b.string().regex(/^[a-zA-Z0-9_.-]+\.(png|svg)$/,"File names must contain only letters, numbers, underscores, dots, or hyphens, and end with .png or .svg.").describe("The local name for saving the fetched file, including extension. Either png or svg."),needsCropping:b.boolean().optional().describe("Whether this image needs cropping based on its transform matrix"),cropTransform:b.array(b.array(b.number())).optional().describe("Figma transform matrix for image cropping"),requiresImageDimensions:b.boolean().optional().describe("Whether this image requires dimension information for CSS variables"),filenameSuffix:b.string().optional().describe("Suffix to add to filename for unique cropped images, provided in the Figma data (e.g., 'abc123')")}).array().describe("The nodes to fetch as images"),pngScale:b.number().positive().optional().default(2).describe("Export scale for PNG images. Optional, defaults to 2 if not specified. Affects PNG images only."),localPath:b.string().describe("The absolute path to the directory where images are stored in the project. If the directory does not exist, it will be created. The format of this path should respect the directory format of the operating system you are running on. Don't use any special character escaping in the path name either.")},ne=b.object(U);async function ie(r,t){try{let{fileKey:e,nodes:i,localPath:s,pngScale:o=2}=ne.parse(r),n=[],l=new Map,w=new Map;for(let h of i){let{nodeId:f,...g}=h,p=f?.replace(/-/g,":"),m=g.fileName;if(g.filenameSuffix&&!m.includes(g.filenameSuffix)){let v=m.split(".").pop();m=`${m.substring(0,m.lastIndexOf("."))}-${g.filenameSuffix}.${v}`}let d={fileName:m,needsCropping:g.needsCropping||!1,cropTransform:g.cropTransform,requiresImageDimensions:g.requiresImageDimensions||!1};if(g.imageRef){let v=`${g.imageRef}-${g.filenameSuffix||"none"}`;if(!g.filenameSuffix&&w.has(v)){let I=w.get(v),S=l.get(I);S.includes(m)||S.push(m),d.requiresImageDimensions&&(n[I].requiresImageDimensions=!0)}else{let I=n.length;n.push({...d,imageRef:g.imageRef}),l.set(I,[m]),w.set(v,I)}}else{let v=n.length;n.push({...d,nodeId:p}),l.set(v,[m])}}let u=await t.downloadImages(e,s,n,{pngScale:o}),c=u.filter(Boolean).length,y=u.map((h,f)=>{let g=h.filePath.split("/").pop()||h.filePath,p=`${h.finalDimensions.width}x${h.finalDimensions.height}`,m=h.wasCropped?" (cropped)":"",d=h.cssVariables?`${p} | ${h.cssVariables}`:p,v=l.get(f)||[g],I=v.length>1?` (also requested as: ${v.filter(S=>S!==g).join(", ")})`:"";return`- ${g}: ${d}${m}${I}`}).join(`
`);return{content:[{type:"text",text:`Downloaded ${c} images:
${y}`}]}}catch(e){return a.error(`Error downloading images from ${r.fileKey}:`,e),{isError:!0,content:[{type:"text",text:`Failed to download images: ${e instanceof Error?e.message:String(e)}`}]}}}var P={name:"download_figma_images",description:"Download SVG and PNG images used in a Figma file based on the IDs of image or icon nodes",parameters:U,handler:ie};var le={name:"Figma MCP Server",version:"0.6.4"};function H(r,{isHTTP:t=!1,outputFormat:e="yaml",skipImageDownloads:i=!1}={}){let s=new ae(le),o=new O(r);return ge(s,o,{outputFormat:e,skipImageDownloads:i}),a.isHTTP=t,s}function ge(r,t,e){r.tool(A.name,A.description,A.parameters,i=>A.handler(i,t,e.outputFormat)),e.skipImageDownloads||r.tool(P.name,P.description,P.parameters,i=>P.handler(i,t))}import{config as me}from"dotenv";import ce from"yargs";import{hideBin as de}from"yargs/helpers";import{resolve as K}from"path";function V(r){return!r||r.length<=4?"****":`****${r.slice(-4)}`}function W(r){let t=ce(de(process.argv)).options({"figma-api-key":{type:"string",description:"Figma API key (Personal Access Token)"},"figma-oauth-token":{type:"string",description:"Figma OAuth Bearer token"},env:{type:"string",description:"Path to custom .env file to load environment variables from"},port:{type:"number",description:"Port to run the server on"},json:{type:"boolean",description:"Output data from tools in JSON format instead of YAML",default:!1},"skip-image-downloads":{type:"boolean",description:"Do not register the download_figma_images tool (skip image downloads)",default:!1}}).help().version("0.6.4").parseSync(),e,i;t.env?(e=K(t.env),i="cli"):(e=K(process.cwd(),".env"),i="default"),me({path:e,override:!0});let s={figmaApiKey:"",figmaOAuthToken:"",useOAuth:!1},o={port:3333,outputFormat:"yaml",skipImageDownloads:!1,configSources:{figmaApiKey:"env",figmaOAuthToken:"none",port:"default",outputFormat:"default",envFile:i,skipImageDownloads:"default"}};return t["figma-api-key"]?(s.figmaApiKey=t["figma-api-key"],o.configSources.figmaApiKey="cli"):process.env.FIGMA_API_KEY&&(s.figmaApiKey=process.env.FIGMA_API_KEY,o.configSources.figmaApiKey="env"),t["figma-oauth-token"]?(s.figmaOAuthToken=t["figma-oauth-token"],o.configSources.figmaOAuthToken="cli",s.useOAuth=!0):process.env.FIGMA_OAUTH_TOKEN&&(s.figmaOAuthToken=process.env.FIGMA_OAUTH_TOKEN,o.configSources.figmaOAuthToken="env",s.useOAuth=!0),t.port?(o.port=t.port,o.configSources.port="cli"):process.env.PORT&&(o.port=parseInt(process.env.PORT,10),o.configSources.port="env"),t.json?(o.outputFormat="json",o.configSources.outputFormat="cli"):process.env.OUTPUT_FORMAT&&(o.outputFormat=process.env.OUTPUT_FORMAT,o.configSources.outputFormat="env"),t["skip-image-downloads"]?(o.skipImageDownloads=!0,o.configSources.skipImageDownloads="cli"):process.env.SKIP_IMAGE_DOWNLOADS==="true"&&(o.skipImageDownloads=!0,o.configSources.skipImageDownloads="env"),!s.figmaApiKey&&!s.figmaOAuthToken&&(console.error("Either FIGMA_API_KEY or FIGMA_OAUTH_TOKEN is required (via CLI argument or .env file)"),process.exit(1)),r||(console.log(`
Configuration:`),console.log(`- ENV_FILE: ${e} (source: ${o.configSources.envFile})`),s.useOAuth?(console.log(`- FIGMA_OAUTH_TOKEN: ${V(s.figmaOAuthToken)} (source: ${o.configSources.figmaOAuthToken})`),console.log("- Authentication Method: OAuth Bearer Token")):(console.log(`- FIGMA_API_KEY: ${V(s.figmaApiKey)} (source: ${o.configSources.figmaApiKey})`),console.log("- Authentication Method: Personal Access Token (X-Figma-Token)")),console.log(`- PORT: ${o.port} (source: ${o.configSources.port})`),console.log(`- OUTPUT_FORMAT: ${o.outputFormat} (source: ${o.configSources.outputFormat})`),console.log(`- SKIP_IMAGE_DOWNLOADS: ${o.skipImageDownloads} (source: ${o.configSources.skipImageDownloads})`),console.log()),{...o,auth:s}}import{randomUUID as pe}from"node:crypto";import z from"express";import{SSEServerTransport as fe}from"@modelcontextprotocol/sdk/server/sse.js";import{StreamableHTTPServerTransport as ue}from"@modelcontextprotocol/sdk/server/streamableHttp.js";import{isInitializeRequest as he}from"@modelcontextprotocol/sdk/types.js";import"@modelcontextprotocol/sdk/server/mcp.js";import{StdioServerTransport as we}from"@modelcontextprotocol/sdk/server/stdio.js";var D=null,$={streamable:{},sse:{}};async function ut(){let r=process.env.NODE_ENV==="cli"||process.argv.includes("--stdio"),t=W(r),e=H(t.auth,{isHTTP:!r,outputFormat:t.outputFormat,skipImageDownloads:t.skipImageDownloads});if(r){let i=new we;await e.connect(i)}else console.log(`Initializing Figma MCP Server in HTTP mode on port ${t.port}...`),await ye(t.port,e)}async function ye(r,t){let e=z();e.use("/mcp",z.json()),e.post("/mcp",async(s,o)=>{a.log("Received StreamableHTTP request");let n=s.headers["mcp-session-id"],l;if(n&&$.streamable[n])a.log("Reusing existing StreamableHTTP transport for sessionId",n),l=$.streamable[n];else if(!n&&he(s.body))a.log("New initialization request for StreamableHTTP sessionId",n),l=new ue({sessionIdGenerator:()=>pe(),onsessioninitialized:y=>{$.streamable[y]=l}}),l.onclose=()=>{l.sessionId&&delete $.streamable[l.sessionId]},await t.connect(l);else{a.log("Invalid request:",s.body),o.status(400).json({jsonrpc:"2.0",error:{code:-32e3,message:"Bad Request: No valid session ID provided"},id:null});return}let w=null,u=s.body.params?._meta?.progressToken,c=0;u&&(a.log(`Setting up progress notifications for token ${u} on session ${n}`),w=setInterval(async()=>{a.log("Sending progress notification",c),await t.server.notification({method:"notifications/progress",params:{progress:c,progressToken:u}}),c++},1e3)),a.log("Handling StreamableHTTP request"),await l.handleRequest(s,o,s.body),w&&clearInterval(w),a.log("StreamableHTTP request handled")});let i=async(s,o)=>{let n=s.headers["mcp-session-id"];if(!n||!$.streamable[n]){o.status(400).send("Invalid or missing session ID");return}console.log(`Received session termination request for session ${n}`);try{await $.streamable[n].handleRequest(s,o)}catch(l){console.error("Error handling session termination:",l),o.headersSent||o.status(500).send("Error processing session termination")}};e.get("/mcp",i),e.delete("/mcp",i),e.get("/sse",async(s,o)=>{a.log("Establishing new SSE connection");let n=new fe("/messages",o);a.log(`New SSE connection established for sessionId ${n.sessionId}`),a.log("/sse request headers:",s.headers),a.log("/sse request body:",s.body),$.sse[n.sessionId]=n,o.on("close",()=>{delete $.sse[n.sessionId]}),await t.connect(n)}),e.post("/messages",async(s,o)=>{let n=s.query.sessionId,l=$.sse[n];if(l)a.log(`Received SSE message for sessionId ${n}`),a.log("/messages request headers:",s.headers),a.log("/messages request body:",s.body),await l.handlePostMessage(s,o);else{o.status(400).send(`No transport found for sessionId ${n}`);return}}),D=e.listen(r,"127.0.0.1",()=>{a.log(`HTTP server listening on port ${r}`),a.log(`SSE endpoint available at http://localhost:${r}/sse`),a.log(`Message endpoint available at http://localhost:${r}/messages`),a.log(`StreamableHTTP endpoint available at http://localhost:${r}/mcp`)}),process.on("SIGINT",async()=>{a.log("Shutting down server..."),await Y($.sse),await Y($.streamable),a.log("Server shutdown complete"),process.exit(0)})}async function Y(r){for(let t in r)try{await r[t]?.close(),delete r[t]}catch(e){console.error(`Error closing transport for session ${t}:`,e)}}async function ht(){if(!D)throw new Error("HTTP server is not running");return new Promise((r,t)=>{D.close(e=>{if(e){t(e);return}D=null;let i=Object.values($.sse).map(s=>s.close());Promise.all(i).then(()=>{r()})})})}export{H as a,W as b,ut as c,ye as d,ht as e};
